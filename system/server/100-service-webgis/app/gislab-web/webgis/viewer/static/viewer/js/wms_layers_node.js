Ext.namespace('WebGIS');

WebGIS.WmsLayersNode = Ext.extend(Ext.tree.TreeNode, {
	layersIconClsMap: {
		POINT: 'point-layer-icon',
		LINE: 'line-layer-icon',
		POLYGON: 'polygon-layer-icon',
	},
	constructor: function(config) {
		config.checked = true;
		config.expanded = true;
		config.expandedable = false;
		config.allowDrag = false;
		config.leaf = false;
		WebGIS.WmsLayersNode.superclass.constructor.apply(this, arguments);
		this.addEvents('layerchange');
		this.layer = config.layer;
		this.layersTree = config.layersTree;
		this.root = this;
		// Stack for passing parameters during checkchange events
		// Used values:
		//  0 - checkchange event generated by user (or programmatically that cause update of layers parameter)
		//  1 - checkchange event generated programmatically on child nodes
		//  2 - checkchange event generated programmatically on parent node - to uncheck it
		//  3 - checkchange event generated programmatically on parent node - to check it but do not change checked state of its child nodes
		this.checkchangeParamsStack = [0];
		this.buildLayersTree();

		var hidden_layers = [];
		this.cascade(function(node) {
			if (node.isLeaf() && node.attributes.config.hidden) {
				hidden_layers.push(node.attributes.text);
				node.attributes.checked = node.parentNode.attributes.checked;
			}
		}, this);
		this.layer.hiddenLayers = hidden_layers;
		this.updateLayersParam();
		this.on('checkchange', this.onNodeCheckChanged);
	},
	updateLayersParamWithTimer: function() {
		if (this.timer) {
			clearTimeout(this.timer);
		}
		this.timer = setTimeout(this.updateLayersParam.bind(this), 800);
	},
	updateLayersParam: function() {
		this.timer = null;
		var visible_layers = this.getVisibleLayers();
		if (this.layer.CLASS_NAME == 'OpenLayers.Layer.WMS') {
			this.layer.mergeNewParams({LAYERS: [].concat(visible_layers).reverse()});
		} else if (this.layer.CLASS_NAME == 'OpenLayers.Layer.TMS') {
			this.layer.layername = [].concat(visible_layers).reverse().join(',');
			this.layer.layers_hash = CryptoJS.MD5(this.layer.layername).toString();
			this.layer.mergeNewParams();// to update legend
		}
		this.fireEvent('layerchange', this, this.layer, visible_layers);
		//console.log(visible_layers);
		//console.log(this.root.checkchangeParamsStack);
	},
	onNodeCheckChanged: function(node, checked) {
		var param = this.root.checkchangeParamsStack.pop();

		if (node.isLeaf() && node.attributes.config.hidden) {
			return;
		}
		// check parent whether this is its first checked child
		if (checked && node.getDepth() > node.root.getDepth()) {
			this.root.checkchangeParamsStack.push(3);
			node.parentNode.getUI().toggleCheck(true);
			// check all hidden layers nodes
			Ext.each(node.parentNode.childNodes, function(n) {
				if (n.isLeaf() && n.attributes.config.hidden) {
					this.root.checkchangeParamsStack.push(1);
					n.getUI().toggleCheck(true);
				}
			});
		}
		if (param == 3) {
			return;
		}

		// uncheck parent whether its every child (except hidden) is unchecked
		if (!checked && node.getDepth() > node.root.getDepth()) {
			var allSiblingsUnchecked = true;
			Ext.each(node.parentNode.childNodes, function(n) {
				if (n.attributes.checked && (!n.isLeaf() || !n.attributes.config.hidden)) {
					allSiblingsUnchecked = false;
					return false;
				}
			});
			if (allSiblingsUnchecked) {
				this.root.checkchangeParamsStack.push(2);
				node.parentNode.getUI().toggleCheck(false);
			}
		}

		// check/uncheck every child if this is group
		if (node.hasChildNodes()) {
			Ext.each(node.childNodes, function(childNode) {
				if (childNode.attributes.checked != checked) {
					this.root.checkchangeParamsStack.push(1);
					childNode.getUI().toggleCheck(checked);
				}
			}, this);
		}

		if (param == 0) {
			// show warning when turning on layer that is not visible in current scale
			if (node.isLeaf() && checked) {
				var layer_info = node.attributes.config;
				var min_scale = layer_info.visibility_scale_min? layer_info.visibility_scale_min : Math.round(node.root.layer.maxScale);
				var max_scale = layer_info.visibility_scale_max? layer_info.visibility_scale_max : Math.round(node.root.layer.minScale);
				if (node.root.layer.map.getScale() < min_scale || node.root.layer.map.getScale() > max_scale) {
					var t = new Ext.ToolTip({
						anchor: 'west',
						target: node.getUI().getEl(),
						//anchorToTarget: false,
						//targetXY: [235, Ext.get(node.getUI().getEl()).getY()+10],
						title: 'Warning',
						html: String.format('Layer {0} is not visible in current scale. It will appear if you zoom map to scale range ({1} - {2})',
											node.attributes.text, min_scale, max_scale),
						hideDelay: 5000,
						closable: false,
						listeners: {
							hide: function(t) {
								t.destroy();
							}
						}
					});
					t.show();
				}
			}
			this.root.checkchangeParamsStack = [0];
			this.root.updateLayersParamWithTimer();
		}
	},
	createLayerNode: function(layer_config) {
		var isGroup = layer_config.hasOwnProperty('layers');
		var node = new Ext.tree.TreeNode({
			text: layer_config.name,
			checked: true,
			leaf: !isGroup,
			hidden: !isGroup && layer_config.hidden,
			iconCls: this.layersIconClsMap[layer_config.geom_type]+(layer_config.queryable? '-queryable' : ''),
			allowDrop: isGroup,
			expanded: true,
			listeners: {
				beforechildrenrendered: function(node) {
					if (node.isLeaf()) {
						var info_button = document.createElement('button');
						info_button.setAttribute('class', 'layer-info');
						info_button.setAttribute('id', 'layerinfo-'+node.attributes.config.name);
						node.getUI().getEl().children[0].insertBefore(info_button, node.getUI().getEl().children[0].children[0]);
					}
				},
				checkchange: this.onNodeCheckChanged,
				move: function(tree, node, oldParent, newParent, index) {
					if (node.attributes.checked) {
						if (oldParent.attributes.checked) {
							// uncheck old parent whether its every child is unchecked
							var allSiblingsUnchecked = true;
							Ext.each(oldParent.childNodes, function(n) {
								if (n.attributes.checked) {
									allSiblingsUnchecked = false;
									return false;
								}
							});
							if (allSiblingsUnchecked) {
								node.root.checkchangeParamsStack.push(2);
								oldParent.getUI().toggleCheck(false);
							}
						}

						this.root.checkchangeParamsStack.push(0);
						node.fireEvent('checkchange', node, true);
					}
				},
				click: function(node, evt) {
					if (evt.getTarget().className == "layer-info") {
						if (node.root.layerInfoWindow) {
							node.root.layerInfoWindow.destroy();
						}
						var layer_info = node.attributes.config;
						// collect info about layer
						var layer_data_parts = [];
						if (layer_info.metadata) {
							layer_data_parts.push([gettext('Title'), layer_info.metadata.title]);
							layer_data_parts.push([gettext('Abstract'), layer_info.metadata.abstract]);
							layer_data_parts.push([gettext('Keyword list'), layer_info.metadata.keyword_list]);
						}
						layer_data_parts.push([gettext('Identification'), layer_info.queryable? gettext("Yes") : gettext("No")]);
						layer_data_parts.push([gettext('Minimal scale'), layer_info.visibility_scale_min? layer_info.visibility_scale_min : Math.round(node.root.layer.maxScale)]);
						layer_data_parts.push([gettext('Maximal scale'), layer_info.visibility_scale_max? layer_info.visibility_scale_max : Math.round(node.root.layer.minScale)]);
						if (layer_info.hasOwnProperty('labels')) {
							layer_data_parts.push([gettext('Labels'), layer_info.labels? gettext("Yes") : gettext("No")]);
						}
						// skip empty records and format to html
						var formatted_data_parts = [];
						Ext.each(layer_data_parts, function(data) {
							if (data[1]) {
								formatted_data_parts.push(String.format('<p><label>{0}:</label>{1}</p>', data[0], data[1]));
							}
						});
						var t = new Ext.ToolTip({
							anchor: 'west',
							target: node.getUI().getEl(),
							title: layer_info.name,
							html: '<div class="layer-info-panel">'+formatted_data_parts.join('')+'</div>',
							closable: true,
							autoHide: false,
							autoScroll: true,
							width: 300,
							maxHeight: 100,
							listeners: {
								hide: function(t) {
									t.destroy();
								}
							}
						});
						t.show();
						node.root.layerInfoWindow = t;
					}
				}
			}
		});
		node.root = this;
		if (isGroup) {
			var groupChecked = false;
			Ext.each(layer_config.layers, function(child_layer_config) {
				var childNode = this.createLayerNode(child_layer_config);
				node.appendChild(childNode);
				groupChecked = groupChecked || childNode.attributes.checked;
			}, this);
			node.attributes.checked = groupChecked;
		} else {
			node.attributes.checked = layer_config.visible && !layer_config.hidden;
			node.attributes.config = layer_config;
		}
		return node;
	},
	buildLayersTree: function() {
		var groupChecked = false;
		Ext.each(this.layersTree, function(layer_config) {
			var node = this.createLayerNode(layer_config);
			groupChecked = groupChecked || node.attributes.checked;
			this.appendChild(node);
		}, this);
		this.attributes.checked = groupChecked;
	},

	orderedLayersNames: function(layers_nodes) {
		layers_nodes.sort(function(l1, l2) {return l1.attributes.config.drawing_order-l2.attributes.config.drawing_order});
		var names = [];
		Ext.each(layers_nodes, function(node) {
			names.push(node.attributes.config.name);
		});
		return names;
	},
	getVisibleLayers: function() {
		var layers_nodes = [];
		this.cascade(function(node) {
			if (node.isLeaf() && node.attributes.checked) {
				layers_nodes.push(node);
			}
		}, this);
		return this.orderedLayersNames(layers_nodes);
	},
	getAllLayers: function() {
		var layers_nodes = [];
		this.cascade(function(node) {
			if (node.isLeaf()) {
				layers_nodes.push(node)
			}
		}, this);
		return this.orderedLayersNames(layers_nodes);
	},
	getEncodedLayersParam: function() {
		var encode_layers_set = function(layers_nodes) {
			var n = layers_nodes[0];
			var parents = [];
			while (n.parentNode && n.parentNode != n.root) {
				parents.push(n.parentNode.attributes.text);
				n = n.parentNode;
			}
			var location = parents.length? '/'+parents.reverse().join('/')+'/' : '/';
			var layers_params = [];
			Ext.each(layers_nodes, function(node) {
				layers_params.push(String.format('{0}:{1}:{2}', node.attributes.text, node.attributes.checked? 1:0, 0));
			}, this);
			return location+layers_params.join(';');
		};
		var param_parts = [];
		var layers_nodes = [];
		var visit_node = function(node) {
			if (node.isLeaf()) {
				layers_nodes.push(node);
			} else {
				if (layers_nodes.length > 0) {
					param_parts.push(encode_layers_set(layers_nodes));
					layers_nodes = [];
				}
				node.eachChild(visit_node, this);
				if (layers_nodes.length > 0) {
					param_parts.push(encode_layers_set(layers_nodes));
					layers_nodes = [];
				}
			}
		}
		visit_node(this);
		return param_parts.join(';');
	},
	setVisibleLayers: function(layernames) {
		this.cascade(function(node) {
			if (node.isLeaf()) {
				node.getUI().toggleCheck(layernames.indexOf(node.attributes.text) != -1);
			}
		});
	}
});
